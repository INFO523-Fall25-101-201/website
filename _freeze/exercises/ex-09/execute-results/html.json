{
  "hash": "c68b3ee654fc2290ecb75f704ec93e33",
  "result": {
    "markdown": "---\ntitle: 'Ex-09: Time series analysis'\nexecute:\n  eval: false\n---\n\n## **Objective:**\n\n-   Analyze AQI time series data to identify underlying patterns, trends, and seasonality.\n\n-   Apply ARIMA models to forecast future AQI values.\n\n-   Explore and apply detrending methods to examine the time series data without its trend component.\n\n-   Investigate the seasonality in the data, understanding how AQI values change over different times of the year.\n\n### **Prerequisites:**\n\n-   **Software and Libraries:** Ensure Python, Jupyter Notebook, and necessary libraries (**`pandas`**, **`matplotlib`**, **`statsmodels`**, **`pmdarima`**) are installed.\n\n-   **Datasets:** Access to the provided dataset with **`date`** and **`aqi_value`** columns, among others, to perform the analysis.\n\n### **Key Concepts:**\n\n#### Time Series Analysis\n\n-   **Time Series Data:** Data points collected or recorded at specific time intervals.\n\n-   **Trend:** The long-term movement in time series data, showing an increase or decrease in the data over time.\n\n-   **Seasonality:** Regular patterns or cycles of fluctuations in time series data that occur due to seasonal factors.\n\n#### ARIMA Modeling\n\n-   [**ARIMA**](https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average) **(AutoRegressive Integrated Moving Average):** A popular statistical method for time series forecasting that captures different aspects of the data, including trend and seasonality.\n\n-   **Parameters (p, d, q):**\n\n    -   **`p`**: The number of lag observations included in the model (AR part).\n\n    -   **`d`**: The degree of differencing required to make the time series stationary.\n\n    -   **`q`**: The size of the moving average window (MA part).\n\n#### Stationarity and Differencing\n\n-   **Stationarity:** A characteristic of a time series whose statistical properties (mean, variance) do not change over time.\n\n-   **Differencing:** A method of transforming a time series to make it stationary by subtracting the previous observation from the current observation.\n\n#### Detrending\n\n-   **Detrending:** The process of removing the trend component from a time series to analyze the cyclical and irregular components.\n\n#### Seasonality Analysis\n\n-   **Seasonal Decompose:** A method to separate out the seasonal component from the time series data, allowing for analysis of specific patterns that repeat over fixed periods.\n\n## Dataset:\n\nThe data this week comes from the EPA's measurements on air quality for Tucson, AZ core-based statistical area (CBSA) for 2022.\n\nWe'll use the dataset: `ad_aqi_tracker_data-2023.csv`, which includes daily observations on air quality, along with multi-year averages.\n\n### Metadata for `ad_aqi_tracker_data-2023.csv`**:**\n\n| Variable             | Class     | Description                          |\n|----------------------|-----------|--------------------------------------|\n| **`Date`**           | DateTime  | Date of observation                  |\n| `AQI Values`         | int       | Air quality index reading            |\n| **`Main Pollutant`** | character | Primary pollutant at time of reading |\n| **`Site Name`**      | character | Name of collection site              |\n| `Site ID`            | character | ID of collection site                |\n| **`Source`**         | double    | Data source                          |\n\n***Note**: You will have to change the data type for some columns to match the above.*\n\n(Source: <https://www.airnow.gov/aqi-basics>)\n\n## **Question:**\n\nHow can we apply ARIMA modeling to forecast future Air Quality Index (AQI) values based on historical data, and what insights can be gained from detrending and analyzing the seasonality in AQI time series data?\n\n## **Step 1: Setup and Data Preprocessing**\n\n1.  Load the dataset into a pandas DataFrame.\n\n2.  Convert the **`date`** column to datetime format and set it as the index of the DataFrame.\n\n3.  Convert the `aqi_value` column as needed.\n\n4.  Plot the **`aqi_value`** time series to visually inspect the data.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom skimpy import clean_columns\n\n# Load the dataset\ndf = pd.read_csv('path_to_your_file.csv')\n\n# Clean column names\ndf = clean_columns(df)\n\n# Assign and remove NAs\ndf.replace({'.': np.nan, '': np.nan}, inplace = True)\ndf.dropna(inplace=True)\n\n# Convert 'date' to datetime and set as index\ndf['date'] = pd.to_datetime(df['date'])\ndf.set_index('date', inplace = True)\n\n# Plot the AQI values\ndf['aqi_value'].plot(title = 'AQI Time Series')\nplt.ylabel('AQI Value')\nplt.show()\n```\n:::\n\n\n## **Step 2: Time Series Decomposition**\n\n1.  Use **`seasonal_decompose`** from the **`statsmodels`** package to decompose the time series into trend, seasonal, and residual components.\n\n2.  Plot the decomposed components to understand the underlying patterns.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom statsmodels.tsa.seasonal import seasonal_decompose\n\n# Decompose the time series\ndecomposition = seasonal_decompose(df['aqi_value'], model = 'additive')\n\n# Plot the decomposed components\ndecomposition.plot()\nplt.show()\n```\n:::\n\n\n## **Part 3: Testing for Stationarity**\n\n1.  Perform an [Augmented Dickey-Fuller](https://en.wikipedia.org/wiki/Augmented_Dickey%E2%80%93Fuller_test) (ADF) test to check the stationarity of the time series.\n\n2.  If the series is not stationary, apply differencing to make it stationary.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nfrom statsmodels.tsa.stattools import adfuller\n\n# Perform Augmented Dickey-Fuller test\nresult = adfuller(df['aqi_value'])\nprint('ADF Statistic: %f' % result[0])\nprint('p-value: %f' % result[1])\n\n# Interpretation\nif result[1] > 0.05:\n    print(\"Series is not stationary\")\nelse:\n    print(\"Series is stationary\")\n```\n:::\n\n\n## **Step 4: ARIMA Model**\n\n1.  Use the **`auto_arima`** function from the **`pmdarima`** package to identify the optimal parameters (p,d,q) for the ARIMA model.\n\n2.  Fit an ARIMA model with the identified parameters.\n\n3.  Plot the original vs. fitted values to assess the model's performance.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfrom pmdarima import auto_arima\n\n# Identify the optimal ARIMA model\nauto_model = auto_arima(df['aqi_value'], start_p = 1, start_q = 1,\n                        test = 'adf',         # use adftest to find optimal 'd'\n                        max_p = 3, max_q = 3, # maximum p and q\n                        m = 1,                # frequency of series\n                        d = None,             # let model determine 'd'\n                        seasonal = False,     # No Seasonality\n                        start_P = 0, \n                        D = 0, \n                        trace = True,\n                        error_action = 'ignore',  \n                        suppress_warnings = True, \n                        stepwise = True)\n\nprint(auto_model.summary())\n\n# Fit ARIMA model\nmodel = auto_model.fit(df['aqi_value'])\n\n# Plot original vs fitted values\ndf['fitted'] = model.predict_in_sample()\ndf[['aqi_value', 'fitted']].plot(title='Original vs. Fitted Values')\nplt.show()\n```\n:::\n\n\n## **Part 5: Forecasting**\n\n1.  Forecast AQI values for the next 30 days using the fitted ARIMA model.\n\n2.  Plot the forecasted values alongside the historical data to visualize the forecast.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Forecast the next 30 days\nforecast, conf_int = model.predict(n_periods = 30, return_conf_int = True)\n\n# Plot the forecast\nplt.figure(figsize = (8, 6))\nplt.plot(df.index, df['aqi_value'], label = 'Historical')\nplt.plot(pd.date_range(df.index[-1], periods = 31, closed = 'right'), forecast, label='Forecast')\nplt.fill_between(pd.date_range(df.index[-1], periods = 31, closed = 'right'), conf_int[:, 0], conf_int[:, 1], color = 'red', alpha = 0.3)\nplt.title('AQI Forecast')\nplt.legend()\nplt.show()\n```\n:::\n\n\n## **Part 6: Detrending and Seasonality Analysis**\n\n1.  Explore different detrending methods (e.g., subtracting a moving average, polynomial detrending) using the **`detrend_aqi`** and **`poly_trend`** columns.\n\n2.  Analyze seasonality patterns in the detrended data.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Detrending using moving average\ndf['moving_avg'] = df['aqi_value'].rolling(window = 12).mean()\ndf['detrended'] = df['aqi_value'] - df['moving_avg']\n\n# Plot detrended data\ndf[['detrended']].plot(title='Detrended AQI Time Series')\nplt.show()\n\n# Assuming seasonality was identified, you can further analyze it,\n# for example, by averaging detrended values by month or another relevant period.\n```\n:::\n\n\n## **Submission:**\n\n-   Submit your Jupyter Notebook via the course's learning management system, including your code, visualizations, and a brief discussion of your findings regarding the impact of cage-free practices on egg production.\n\n",
    "supporting": [
      "ex-09_files"
    ],
    "filters": [],
    "includes": {}
  }
}